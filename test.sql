/* 
   -----------------------------------------------------------------------------------
   Framework: OFSAA Data Quality & Reconciliation
   Module: Account Status Code Validation (optimized)
   Purpose: Validates Staging Data against Metadata and Business Rules
   - Key optimizations applied:
     1) MATERIALIZE hints for heavy/reused CTEs
     2) Avoid cross-joining TMP_VARS repeatedly (use scalar subqueries)
     3) Replace REGEXP_LIKE with TRANSLATE-based check (much faster at scale)
     4) Precompute CUST_TYPE_CD split once (TMP_CUST_TYPE_SPLIT)
     5) Remove unnecessary DISTINCT
   -----------------------------------------------------------------------------------
*/

WITH 
-- =============================================================================
-- 1. INITIALIZATION & CONFIGURATION (single-row TMP_VARS)
-- =============================================================================
TMP_MAX_FIC_MIS_DATE AS (
    SELECT MAX(FIC_MIS_DATE) AS MAX_FIC_MIS_DATE FROM OFSAAATM.STG_CARDS
),
TMP_MAX_DATA_DUMP_DT AS (
    SELECT MAX(DATA_DUMP_DT) AS MAX_DATA_DUMP_DT FROM OFSAAATM.STG_CARDS
),

TMP_VARS AS (
    /* single-row config - use scalar subqueries elsewhere instead of joining this repeatedly */
    SELECT 
        'OFSAAATM'                      AS DATABASE_NAME,
        'STG_CARDS'                     AS TABLE_NAME,
        'V_ACCT_STATUS_CODE'            AS DATA_ELEMENT,
        'ACCT_STATUS_CD'                AS BDE_NAME, 
        
        -- Validation Rules
        '^[-a-zA-Z0-9\s!@#$%^&*()_+=?<>:;]+$'  AS DE_REGEX, 
        -- Added explicit allowed chars string for TRANSLATE-based check (avoid regex)
        'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !@#$%^&*()_+=?<>:;-' AS DE_ALLOWED_CHARS,
        'VARCHAR2'                      AS DE_DATA_TYPE,
        'CHAR,VARCHAR2'                 AS FCDM_DE_CMPTL_DATA_TYPES, 
        
        -- Rule Descriptions
        'Check for Nulls'               AS DQ_RULE_COMPLETENESS_1,
        'Check Format/Type'             AS DQ_RULE_VALIDITY_1,
        'Check Length'                  AS DQ_RULE_VALIDITY_2,
        'Check Ref Integrity'           AS DQ_RULE_ACCURACY_1,
        
        -- Dimensions
        'COMPLETENESS'                  AS DQ_DIMENSION_COMPLETENESS,
        'VALIDITY'                      AS DQ_DIMENSION_VALIDITY,
        'ACCURACY'                      AS DQ_DIMENSION_ACCURACY,
        
        -- Constants
        'ALL'                           AS DQ_DIMENSION_ALL,
        'ALL'                           AS DQ_RULE_ALL,
        'ALL'                           AS SOURCE_CODE_ALL,
        'IND,ORG'                       AS CUST_TYPE_CD,

        D.MAX_FIC_MIS_DATE,
        D2.MAX_DATA_DUMP_DT
    FROM TMP_MAX_FIC_MIS_DATE D, TMP_MAX_DATA_DUMP_DT D2
),

-- =============================================================================
-- 2. STAGING EXTRACT (MATERIALIZE TMP_DQ)
--    - Materialize will force a single evaluation and reuse of TMP_DQ.
--    - If TMP_DQ is very large consider creating a GTT outside this query instead.
-- =============================================================================
TMP_DQ AS (
    SELECT /*+ MATERIALIZE */
        V_Account_number               AS V_ACCOUNT_NUMBER_CSA_1,
        v_cust_ref_code                AS V_CUST_REF_CODE_CSA_2, 
        FIC_MIS_DATE,
        V_ACCT_STATUS_CODE,
        V_DATA_JURISDICTION,
        V_DATA_ORIGIN
    FROM OFSDFATM.STG_CARDS
    WHERE fic_mis_date = (SELECT MAX_FIC_MIS_DATE FROM TMP_VARS)
      AND UPPER(V_DATA_JURISDICTION) LIKE 'C%'
      -- 'NOT IN' with wildcard is invalid; use NOT LIKE for prefix exclusion
      AND UPPER(V_DATA_JURISDICTION) NOT LIKE 'CA99%'
),

-- =============================================================================
-- 3. METADATA & REFERENCE DATA
--    - Metadata lookup precomputed from dictionary (single small CTE)
-- =============================================================================
TMP_CSA_BDE_DD AS (
    SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, CHAR_LENGTH 
    FROM ALL_TAB_COLUMNS
    WHERE OWNER = (SELECT DATABASE_NAME FROM TMP_VARS)
      AND TABLE_NAME = (SELECT TABLE_NAME FROM TMP_VARS)
      AND COLUMN_NAME = (SELECT DATA_ELEMENT FROM TMP_VARS)
),

TMP_FCDM_BDE_DD AS (
    /* FCDM expected type/length (still a single-row source) */
    SELECT 'VARCHAR2' AS DATA_TYPE, 20 AS CHAR_LENGTH FROM DUAL
),

TMP_GAMLREF AS (
    SELECT /*+ MATERIALIZE */
        TRIM(ORACLE_DOV)          AS ORACLE_DOV,
        ORACLE_DOV_DESC
    FROM OFSDFATM.TD_GAML_REF_EDF_TO_CSA_LOOKUP
    WHERE ORACLE_DOV IS NOT NULL
      AND ORACLE_COL_NM = (SELECT DATA_ELEMENT FROM TMP_VARS)
      AND ORACLE_ACTIVE_IND = 'Y'
),

-- =============================================================================
-- 4. POPULATION SCOPING
--    - Materialize CUA, pre-split CUST_TYPE_CD once
-- =============================================================================

TMP_CUA AS (
    SELECT /*+ MATERIALIZE */
        CUA.CUST_INTRL_ID,
        ACCT.ACCT_INTRL_ID,
        ACCT.SRC_SYS_CD,
        ACCT.JRSDCN_CD,
        CUA.DATA_DUMP_DT,
        ACCT.V_ACCT_STATUS_CODE,     
        ACCT.V_ACCOUNT_NUMBER_CSA_1  
    FROM OFSAAATM.CUST_ACCT CUA
    JOIN OFSAAATM.CUST_ACCT_ROLE CUAR 
        ON CUAR.CUST_ACCT_ROLE_CD = CUA.CUST_ACCT_ROLE_CD
       AND CUAR.DATA_DUMP_DT = (SELECT MAX_DATA_DUMP_DT FROM TMP_VARS)
       AND SUBSTR(NVL(CUAR.CUST_ACCT_ROLE_DESC_TX, 'N'), 1, 1) = 'Y'
    JOIN OFSAAATM.ACCT ACCT 
        ON ACCT.ACCT_INTRL_ID = CUA.ACCT_INTRL_ID
       AND ACCT.DATA_DUMP_DT = (SELECT MAX_DATA_DUMP_DT FROM TMP_VARS)
       AND ACCT.JRSDCN_CD LIKE 'C%'
       AND ACCT.JRSDCN_CD NOT IN ('CA99')
       AND ACCT.ACCT_STAT_CD = 'A'
    WHERE CUA.DATA_DUMP_DT = (SELECT MAX_DATA_DUMP_DT FROM TMP_VARS)
    -- GROUP BY removed: not needed here; keep raw rows to avoid costly sort/dedup
),

-- Pre-split customer types once (avoid per-row CONNECT BY executions)
TMP_CUST_TYPE_SPLIT AS (
    SELECT TRIM(REGEXP_SUBSTR((SELECT CUST_TYPE_CD FROM TMP_VARS), '[^,]+', 1, LEVEL)) AS CUST_TYPE_CD
    FROM DUAL
    CONNECT BY LEVEL <= REGEXP_COUNT((SELECT CUST_TYPE_CD FROM TMP_VARS), ',') + 1
),

TMP_CU AS (
    SELECT /*+ MATERIALIZE */
        CU.CUST_INTRL_ID,
        CU.CUST_TYPE_CD,
        TMP_CUA.SRC_SYS_CD,
        TMP_CUA.ACCT_INTRL_ID,
        TMP_CUA.JRSDCN_CD,
        CU.DATA_DUMP_DT
    FROM OFSAAATM.CUST CU
    JOIN TMP_CUA ON TMP_CUA.CUST_INTRL_ID = CU.CUST_INTRL_ID
               AND TMP_CUA.DATA_DUMP_DT = (SELECT MAX_DATA_DUMP_DT FROM TMP_VARS)
    -- join to precomputed list of allowed cust types (single small join)
    JOIN TMP_CUST_TYPE_SPLIT CTS ON CTS.CUST_TYPE_CD = CU.CUST_TYPE_CD
    WHERE CU.JRSDCN_CD LIKE 'C%'
      AND CU.JRSDCN_CD NOT IN ('CA99')
),

TMP_FCC AS (
    SELECT /*+ MATERIALIZE */
        TMP_CU.CUST_INTRL_ID,
        TMP_CU.ACCT_INTRL_ID,
        ER.V_ENTITY_ID,
        TMP_CU.CUST_TYPE_CD,
        TMP_CU.SRC_SYS_CD,
        TMP_CU.DATA_DUMP_DT,
        TMP_CU.JRSDCN_CD
    FROM OFSDFATM.FCC_ER_MAPPING ER
    JOIN TMP_CU ON ER.V_GLOBAL_ID = TMP_CU.CUST_INTRL_ID
    WHERE ER.F_LRI_FLAG = 'Y'
),

-- =============================================================================
-- 5. VALIDATION ENGINE (core)
--    - Materialize TMP_BASE_ACCT; removed DISTINCT to avoid expensive sorts.
--    - Use TRANSLATE-based "allowed characters" check instead of REGEXP_LIKE.
--    - Join TMP_CSA_BDE_DD by COLUMN_NAME = DATA_ELEMENT (not by data type).
-- =============================================================================

TMP_BASE_ACCT AS (
    SELECT /*+ MATERIALIZE */
        TMP_DQ.V_ACCOUNT_NUMBER_CSA_1,
        TMP_FCC.CUST_INTRL_ID,
        TMP_FCC.CUST_TYPE_CD,
        TMP_DQ.V_DATA_ORIGIN,
        TMP_DQ.V_ACCT_STATUS_CODE,

        -- DQ Checks
        CASE WHEN TMP_DQ.V_ACCT_STATUS_CODE IS NULL THEN 1 ELSE 0 END AS ERR_COMPLETENESS_1,

        -- VALIDITY_1: length vs column metadata OR allowed-format check (TRANSLATE approach)
        CASE WHEN TMP_DQ.V_ACCT_STATUS_CODE IS NOT NULL
             AND (
                NVL(LENGTH(TMP_DQ.V_ACCT_STATUS_CODE),0) > NVL((SELECT CHAR_LENGTH FROM TMP_CSA_BDE_DD), 4000)
                OR -- TRANSLATE-based invalid character detection:
                   -- Map allowed chars to spaces; if trimmed remainder exists â†’ invalid char present
                   NVL(TRIM(TRANSLATE(
                        TMP_DQ.V_ACCT_STATUS_CODE,
                        (SELECT DE_ALLOWED_CHARS FROM TMP_VARS),
                        RPAD(' ', LENGTH((SELECT DE_ALLOWED_CHARS FROM TMP_VARS)))
                   )), '') <> ''
             )
        THEN 1 ELSE 0 END AS ERR_VALIDITY_1,

        -- VALIDITY_2: data-type compatibility + FCDM length
        CASE WHEN TMP_DQ.V_ACCT_STATUS_CODE IS NOT NULL
             AND (
                -- check if column DATA_TYPE is in allowed list
                ( (SELECT DATA_TYPE FROM TMP_CSA_BDE_DD) NOT IN
                  ( SELECT TRIM(REGEXP_SUBSTR((SELECT FCDM_DE_CMPTL_DATA_TYPES FROM TMP_VARS), '[^,]+', 1, LEVEL))
                    FROM DUAL CONNECT BY LEVEL <= REGEXP_COUNT((SELECT FCDM_DE_CMPTL_DATA_TYPES FROM TMP_VARS), ',') + 1
                  )
                )
                OR NVL(LENGTH(TMP_DQ.V_ACCT_STATUS_CODE),0) > (SELECT CHAR_LENGTH FROM TMP_FCDM_BDE_DD)
             )
        THEN 1 ELSE 0 END AS ERR_VALIDITY_2,

        -- ACCURACY_1: reference lookup (compare trimmed upper to handle case/padding)
        CASE WHEN TMP_DQ.V_ACCT_STATUS_CODE IS NOT NULL
             AND ( SELECT COUNT(1)
                   FROM TMP_GAMLREF GR
                   WHERE UPPER(TRIM(GR.ORACLE_DOV)) = UPPER(TRIM(TMP_DQ.V_ACCT_STATUS_CODE))
                 ) = 0
        THEN 1 ELSE 0 END AS ERR_ACCURACY_1

    FROM TMP_DQ
    -- use scalar subqueries for TMP_VARS values (no join on tmp_vars)
    JOIN TMP_CSA_BDE_DD ON TMP_CSA_BDE_DD.COLUMN_NAME = (SELECT DATA_ELEMENT FROM TMP_VARS)
    JOIN TMP_FCDM_BDE_DD ON 1=1  -- single-row reference
    -- join on customer/internal id (do NOT equate account-number string to internal surrogate key)
    LEFT JOIN TMP_FCC ON TMP_DQ.V_CUST_REF_CODE_CSA_2 = TMP_FCC.CUST_INTRL_ID
    -- TMP_GAMLREF is referenced through scalar subquery in ACCURACY_1 above
),

TMP_BASE_ACCT_COMPLETE AS (
    SELECT * FROM TMP_BASE_ACCT WHERE ERR_COMPLETENESS_1 = 0
),

-- =============================================================================
-- 6. AGGREGATION (GID LEVEL)
--    - Removed DISTINCT within aggregations where not required.
-- =============================================================================

TMP_BASE_GID AS (
    SELECT 
        CUST_INTRL_ID,
        CUST_TYPE_CD,
        V_DATA_ORIGIN,
        V_ACCT_STATUS_CODE,
        MAX(ERR_COMPLETENESS_1) AS ERR_COMPLETENESS_1,
        MAX(ERR_VALIDITY_1)     AS ERR_VALIDITY_1,
        MAX(ERR_VALIDITY_2)     AS ERR_VALIDITY_2,
        MAX(ERR_ACCURACY_1)     AS ERR_ACCURACY_1
    FROM TMP_BASE_ACCT
    GROUP BY CUST_INTRL_ID, CUST_TYPE_CD, V_DATA_ORIGIN, V_ACCT_STATUS_CODE
),

TMP_BASE_GID_COMPLETE AS (
    SELECT * FROM TMP_BASE_GID WHERE ERR_COMPLETENESS_1 = 0
),

-- =============================================================================
-- 7. REPORTING CUBE GENERATION (ACCOUNT + GID)
--    - Aggregations use TMP_BASE_ACCT / TMP_BASE_ACCT_COMPLETE / TMP_BASE_GID as sources
--    - Kept the shape of the reporting cube; removed redundant DISTINCTs
-- =============================================================================

TMP_ALLDQ_ACCT_INDSRC AS (
    SELECT (SELECT DQ_DIMENSION_ALL FROM TMP_VARS) AS DQ_DIMENSION,
           (SELECT DQ_RULE_ALL FROM TMP_VARS) AS DQ_RULE,
           BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN (ERR_COMPLETENESS_1=1 OR ERR_VALIDITY_1=1 OR ERR_VALIDITY_2=1 OR ERR_ACCURACY_1=1) 
                     THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_ALLDQ_ACCT_ALLSRC AS (
    SELECT (SELECT DQ_DIMENSION_ALL FROM TMP_VARS), (SELECT DQ_RULE_ALL FROM TMP_VARS), (SELECT SOURCE_CODE_ALL FROM TMP_VARS),
           BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN (ERR_COMPLETENESS_1=1 OR ERR_VALIDITY_1=1 OR ERR_VALIDITY_2=1 OR ERR_ACCURACY_1=1) 
                     THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT
        GROUP BY CUST_TYPE_CD
    ) BASE
),

TMP_DQ_ACCT_COMPLETENESS_1_INDSRC AS (
    SELECT (SELECT DQ_DIMENSION_COMPLETENESS FROM TMP_VARS) AS DQ_DIMENSION,
           (SELECT DQ_RULE_COMPLETENESS_1 FROM TMP_VARS) AS DQ_RULE,
           BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_COMPLETENESS_1=1 THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_DQ_ACCT_COMPLETENESS_1_ALLSRC AS (
    SELECT (SELECT DQ_DIMENSION_COMPLETENESS FROM TMP_VARS), (SELECT DQ_RULE_COMPLETENESS_1 FROM TMP_VARS), (SELECT SOURCE_CODE_ALL FROM TMP_VARS),
           BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_COMPLETENESS_1=1 THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT
        GROUP BY CUST_TYPE_CD
    ) BASE
),

TMP_DQ_ACCT_VALIDITY_1_INDSRC AS (
    SELECT (SELECT DQ_DIMENSION_VALIDITY FROM TMP_VARS), (SELECT DQ_RULE_VALIDITY_1 FROM TMP_VARS), BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_VALIDITY_1=1 THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT_COMPLETE
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_DQ_ACCT_VALIDITY_1_ALLSRC AS (
    SELECT (SELECT DQ_DIMENSION_VALIDITY FROM TMP_VARS), (SELECT DQ_RULE_VALIDITY_1 FROM TMP_VARS), (SELECT SOURCE_CODE_ALL FROM TMP_VARS),
           BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_VALIDITY_1=1 THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT_COMPLETE
        GROUP BY CUST_TYPE_CD
    ) BASE
),

TMP_DQ_ACCT_VALIDITY_2_INDSRC AS (
    SELECT (SELECT DQ_DIMENSION_VALIDITY FROM TMP_VARS), (SELECT DQ_RULE_VALIDITY_2 FROM TMP_VARS), BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_VALIDITY_2=1 THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT_COMPLETE
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_DQ_ACCT_VALIDITY_2_ALLSRC AS (
    SELECT (SELECT DQ_DIMENSION_VALIDITY FROM TMP_VARS), (SELECT DQ_RULE_VALIDITY_2 FROM TMP_VARS), (SELECT SOURCE_CODE_ALL FROM TMP_VARS),
           BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_VALIDITY_2=1 THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT_COMPLETE
        GROUP BY CUST_TYPE_CD
    ) BASE
),

TMP_DQ_ACCT_ACCURACY_1_INDSRC AS (
    SELECT (SELECT DQ_DIMENSION_ACCURACY FROM TMP_VARS), (SELECT DQ_RULE_ACCURACY_1 FROM TMP_VARS), BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_ACCURACY_1=1 THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT_COMPLETE
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_DQ_ACCT_ACCURACY_1_ALLSRC AS (
    SELECT (SELECT DQ_DIMENSION_ACCURACY FROM TMP_VARS), (SELECT DQ_RULE_ACCURACY_1 FROM TMP_VARS), (SELECT SOURCE_CODE_ALL FROM TMP_VARS),
           BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT V_ACCOUNT_NUMBER_CSA_1) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_ACCURACY_1=1 THEN V_ACCOUNT_NUMBER_CSA_1 END) AS FAILED_RECORDS
        FROM TMP_BASE_ACCT_COMPLETE
        GROUP BY CUST_TYPE_CD
    ) BASE
),

-- --- GID (CUSTOMER) LEVEL ---
TMP_ALLDQ_GID_INDSRC AS (
    SELECT 'ALL' AS DQ_DIMENSION, 'ALL' AS DQ_RULE, BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN (ERR_COMPLETENESS_1=1 OR ERR_VALIDITY_1=1 OR ERR_VALIDITY_2=1 OR ERR_ACCURACY_1=1) THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_ALLDQ_GID_ALLSRC AS (
    SELECT 'ALL','ALL', (SELECT SOURCE_CODE_ALL FROM TMP_VARS), BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN (ERR_COMPLETENESS_1=1 OR ERR_VALIDITY_1=1 OR ERR_VALIDITY_2=1 OR ERR_ACCURACY_1=1) THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID
        GROUP BY CUST_TYPE_CD
    ) BASE
),

TMP_DQ_GID_COMPLETENESS_1_INDSRC AS (
    SELECT (SELECT DQ_DIMENSION_COMPLETENESS FROM TMP_VARS), (SELECT DQ_RULE_COMPLETENESS_1 FROM TMP_VARS),
           BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_COMPLETENESS_1=1 THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_DQ_GID_COMPLETENESS_1_ALLSRC AS (
    SELECT (SELECT DQ_DIMENSION_COMPLETENESS FROM TMP_VARS), (SELECT DQ_RULE_COMPLETENESS_1 FROM TMP_VARS), (SELECT SOURCE_CODE_ALL FROM TMP_VARS),
           BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_COMPLETENESS_1=1 THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID
        GROUP BY CUST_TYPE_CD
    ) BASE
),

TMP_DQ_GID_VALIDITY_1_INDSRC AS (
    SELECT (SELECT DQ_DIMENSION_VALIDITY FROM TMP_VARS), (SELECT DQ_RULE_VALIDITY_1 FROM TMP_VARS), BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_VALIDITY_1=1 THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID_COMPLETE
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_DQ_GID_VALIDITY_1_ALLSRC AS (
    SELECT (SELECT DQ_DIMENSION_VALIDITY FROM TMP_VARS), (SELECT DQ_RULE_VALIDITY_1 FROM TMP_VARS), (SELECT SOURCE_CODE_ALL FROM TMP_VARS),
           BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_VALIDITY_1=1 THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID_COMPLETE
        GROUP BY CUST_TYPE_CD
    ) BASE
),

TMP_DQ_GID_VALIDITY_2_INDSRC AS (
    SELECT (SELECT DQ_DIMENSION_VALIDITY FROM TMP_VARS), (SELECT DQ_RULE_VALIDITY_2 FROM TMP_VARS), BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_VALIDITY_2=1 THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID_COMPLETE
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_DQ_GID_VALIDITY_2_ALLSRC AS (
    SELECT (SELECT DQ_DIMENSION_VALIDITY FROM TMP_VARS), (SELECT DQ_RULE_VALIDITY_2 FROM TMP_VARS), (SELECT SOURCE_CODE_ALL FROM TMP_VARS),
           BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_VALIDITY_2=1 THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID_COMPLETE
        GROUP BY CUST_TYPE_CD
    ) BASE
),

TMP_DQ_GID_ACCURACY_1_INDSRC AS (
    SELECT (SELECT DQ_DIMENSION_ACCURACY FROM TMP_VARS), (SELECT DQ_RULE_ACCURACY_1 FROM TMP_VARS), BASE.SOURCE_CODE, BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, V_DATA_ORIGIN AS SOURCE_CODE,
               COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_ACCURACY_1=1 THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID_COMPLETE
        GROUP BY CUST_TYPE_CD, V_DATA_ORIGIN
    ) BASE
),

TMP_DQ_GID_ACCURACY_1_ALLSRC AS (
    SELECT (SELECT DQ_DIMENSION_ACCURACY FROM TMP_VARS), (SELECT DQ_RULE_ACCURACY_1 FROM TMP_VARS), (SELECT SOURCE_CODE_ALL FROM TMP_VARS),
           BASE.CUST_TYPE_CD, BASE.TOTAL_RECORDS, BASE.FAILED_RECORDS
    FROM (
        SELECT CUST_TYPE_CD, COUNT(DISTINCT CUST_INTRL_ID) AS TOTAL_RECORDS,
               COUNT(DISTINCT CASE WHEN ERR_ACCURACY_1=1 THEN CUST_INTRL_ID END) AS FAILED_RECORDS
        FROM TMP_BASE_GID_COMPLETE
        GROUP BY CUST_TYPE_CD
    ) BASE
),

-- =============================================================================
-- 8. UNION & FINAL OUTPUT
-- =============================================================================

TMP_DQ_ACCT_RESULTS AS (
    SELECT 'ACCOUNT' AS RESULT_TYPE, DQ_DIMENSION, DQ_RULE, CUST_TYPE_CD, SOURCE_CODE, TOTAL_RECORDS, FAILED_RECORDS
    FROM (
        SELECT * FROM TMP_ALLDQ_ACCT_ALLSRC UNION ALL SELECT * FROM TMP_ALLDQ_ACCT_INDSRC UNION ALL
        SELECT * FROM TMP_DQ_ACCT_COMPLETENESS_1_ALLSRC UNION ALL SELECT * FROM TMP_DQ_ACCT_COMPLETENESS_1_INDSRC UNION ALL
        SELECT * FROM TMP_DQ_ACCT_VALIDITY_1_ALLSRC UNION ALL SELECT * FROM TMP_DQ_ACCT_VALIDITY_1_INDSRC UNION ALL
        SELECT * FROM TMP_DQ_ACCT_VALIDITY_2_ALLSRC UNION ALL SELECT * FROM TMP_DQ_ACCT_VALIDITY_2_INDSRC UNION ALL
        SELECT * FROM TMP_DQ_ACCT_ACCURACY_1_ALLSRC UNION ALL SELECT * FROM TMP_DQ_ACCT_ACCURACY_1_INDSRC
    )
),

TMP_DQ_GID_RESULTS AS (
    SELECT 'GID' AS RESULT_TYPE, DQ_DIMENSION, DQ_RULE, CUST_TYPE_CD, SOURCE_CODE, TOTAL_RECORDS, FAILED_RECORDS
    FROM (
        SELECT * FROM TMP_ALLDQ_GID_ALLSRC UNION ALL SELECT * FROM TMP_ALLDQ_GID_INDSRC UNION ALL
        SELECT * FROM TMP_DQ_GID_COMPLETENESS_1_ALLSRC UNION ALL SELECT * FROM TMP_DQ_GID_COMPLETENESS_1_INDSRC UNION ALL
        SELECT * FROM TMP_DQ_GID_VALIDITY_1_ALLSRC UNION ALL SELECT * FROM TMP_DQ_GID_VALIDITY_1_INDSRC UNION ALL
        SELECT * FROM TMP_DQ_GID_VALIDITY_2_ALLSRC UNION ALL SELECT * FROM TMP_DQ_GID_VALIDITY_2_INDSRC UNION ALL
        SELECT * FROM TMP_DQ_GID_ACCURACY_1_ALLSRC UNION ALL SELECT * FROM TMP_DQ_GID_ACCURACY_1_INDSRC
    )
),

TMP_DQ_RESULTS AS (
    SELECT 
        (SELECT DATABASE_NAME FROM TMP_VARS)    AS DATABASE_NAME,
        (SELECT TABLE_NAME FROM TMP_VARS)       AS TABLE_NAME,
        (SELECT DATA_ELEMENT FROM TMP_VARS)     AS DATA_ELEMENT,
        (SELECT BDE_NAME FROM TMP_VARS)         AS BDE_NAME,
        RESULTS.DQ_DIMENSION, RESULTS.DQ_RULE, RESULTS.CUST_TYPE_CD, RESULTS.SOURCE_CODE, RESULTS.RESULT_TYPE,
        (SELECT MAX_FIC_MIS_DATE FROM TMP_VARS) AS FIC_MIS_DATE,
        RESULTS.TOTAL_RECORDS, RESULTS.FAILED_RECORDS,
        (RESULTS.TOTAL_RECORDS - RESULTS.FAILED_RECORDS) AS COUNT_OF_PASS,
        TRUNC(((RESULTS.TOTAL_RECORDS - RESULTS.FAILED_RECORDS)/NULLIF(RESULTS.TOTAL_RECORDS,0))*100, 2) AS PASS_RATE
    FROM (
        SELECT * FROM TMP_DQ_GID_RESULTS
        UNION ALL
        SELECT * FROM TMP_DQ_ACCT_RESULTS
    ) RESULTS
    ORDER BY RESULTS.SOURCE_CODE, DQ_DIMENSION, CUST_TYPE_CD, RESULT_TYPE
)

SELECT * FROM TMP_DQ_RESULTS;
